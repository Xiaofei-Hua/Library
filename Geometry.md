#  Geometry

## 距离

设 $A(x, y)$ ，$B(a, b)$

### 欧几里得距离

$|AB| = \sqrt{(x - a)^2 + (y-b)^2}$

### 曼哈顿距离

$|AB| = |x - a| + |y-b|$

### 切比雪夫距离

$|AB|=max(|x-a|, |y-b|)$

### 曼哈顿转切比雪夫

将坐标 $(x, y)$ 变换为 $(x + y, x - y)$ ，原坐标系中的曼哈顿距离等于新坐标系中的切比雪夫距离

转化后坐标有可能变为负数，某些数据结构可能无法处理负数的情况，故应当把处理后的坐标再加上相同的偏移量变为正数

切比雪夫便于求最大值，形成的图形均为正方形，便于数据结构维护

### 切比雪夫转曼哈顿

将坐标 $(x, y)$ 变换为 $(\frac{x + y}{2}, \frac{x - y}{2})$ ，原坐标系中的切比雪夫距离等于新坐标系中的曼哈顿距离

转化后坐标有可能变为浮点数，故应当把处理前的坐标 $\times 2$

曼哈顿距离便于求和，利用前缀和等，形成的图形为菱形，不便于数据结构维护

****

## 正方形转锥形坐标变换

$(x, y) \rightarrow (x + y, x - y + n - 1)$ 

原坐标系中以 $(x, y)$ 为顶点的锥形等价于新坐标系中以 $(x + y, x - y + n -1)$ 为左上顶点的矩形

****

## 点积与叉积

点积： $a · b = |a| |b|cos \theta$ ，通常判断两个向量的夹角与 $90°$ 的关系

叉积：$a · b = |a| |b|sin\theta$ ，$\theta$ 为 $a$ 沿逆时针方向旋转到 $b$ 的角度，通常判断一个向量是否在另一个向量的左边。所求的值的大小为以两个向量为边长的有向平行四边形的面积

****

## 扫描线

对所有两点构成的线段进行极角排序，考虑维护其他点与当前线段对答案的影响，在枚举到下一条线段前，若两点在维护的值的序列中有序，则交换当前线段两点所维护的值

例题：求所有点中面积最大或最小的三角形（即维护每个点到当前线段的距离）

****

## 旋转卡壳

凸包上各极点到一条极边的距离存在单峰性

算法流程：设定初始边指针 $p$ ，并找到其对踵点指针 $q$ ，$p$ 每指向下一条边，若 $p$ 点到 $p$ 边的距离小于等于 $q$ 的下一个点到 $p$ 边的距离，则 $q$ 指向下一个点，直到找到对踵点，更新答案

应用：

1. 凸多边形直径（平面最远点对）

2. 凸多边形宽

3. 凸多边形间最大 / 最小距离

4. 最小面积 / 周长外接矩形
   
   1. 结论：最小外接矩形一定有一条边与凸包的一条极边共线
   2. 在旋转卡壳时，多维护边方向上的两个极点即可

***

## 闵可夫斯基和

定义：点集 $P$ 和点集 $Q$ 的闵可夫斯基和 $P + Q$ 定义为 $P + Q = {a + b | a \in P, b\in Q}$ ，即把点集 $Q$ 中的每个点看做一个向量，将点集 $P$ 中每个点沿这些向量平移，最终得到的结果的集合就是点集 $P + Q$。仅讨论凸包的闵可夫斯基和

1. 若点集合 $P$ ，$Q$ 为凸集，则其闵可夫斯基和 $P+Q$ 也是凸集
2. 若点集合 $P$ ，$Q$ 为凸集，则其闵可夫斯基和 $P+Q$ 的边集是由凸集 $P$ ，$Q$ 的边按极角排序后连接的结果

考虑当 $A$ 的轮廓是凸函数 $(i, f_i)$ ， $B$ 的轮廓是凸函数 $(j, g_j)$ 时，$A+B$ 的轮廓就是 $(k, max_{i + j = k} \  f_i + g_j)$ 。这也说明了为什么 $max / min$ 加法卷积能保持凸性

当 $f$ 和 $g$ 都是凸函数时，他们的 $min$ 加法卷积 $h_k=min_{i + j = k} \ f_i + g_j$ 有如下的快速计算方式：

考虑对 $f$ 和 $g$ 做差分，有 $a_i = f_i - f_{i-1}$ 和 $b_i = g_i - g_{i-1}$ 。那么 $h_k$ 本质上就是取 $a$ 的一个前缀和 $b$ 的一个前缀，使得取得的元素个数为 $k$ 且元素和最小。因为 $a$ 和 $b$ 递增，因此本质上就是对 $a$ 和 $b$ 这两个数组进行归并排序， $h_k$ 就是前 $k$ 个元素的和。也就是说，卷积后函数的斜率，等于卷积前两个函数的斜率做归并排序，这让我们可以快速对凸函数完成卷积转移。



给定 $n$ 个向量，要求选出一些向量，使得它们的和的模长最大。

如果把一个向量看作 ${(0,0), \ (x_i, y_i)}$ 这样一个点集，那么我们发现所有可行解恰好就是这 $n$ 个点集的闵可夫斯基和。

显然最优解一定在所有点集的闵可夫斯基和对应的凸包上。$n$ 个凸多边形的闵可夫斯基和凸包上的边一定是这 $n$ 个多边形原有的边平移围成的。而一个 $A \rightarrow B$ 的向量可以看作由 $A \rightarrow B$ 和 $B \rightarrow A$ 两条边组成的“二边形”。于是我们就知道了最终凸包上一共有 $2n$ 条边，也就是 $n$ 条向量 $(x_i, y_i)$ 构成的边和 $n$ 条向量 $(-x_i, -y_i)$ 构成的边。只需要把这 $2n$ 条边按方向和斜率排序，就能按顺序遍历这个凸包。枚举凸包上每个点，找到距原点距离最远的点，即为答案。

 $(sx, sy)$ 为凸包上的一个起点。凸包上的边在数组中是按 $2 \rightarrow 1 \rightarrow 3 \rightarrow 4$ 象限顺序排序的（注意，一个两维都为正的向量自身属于第一象限，但是它在凸包上属于第四象限）。想要在凸包上走，就要找到第四象限左侧的第一个点，这个点就是 $y$ 坐标最小的且在 $y$ 轴左侧离 $y$ 轴最近的点，即 $(sx, sy)$ 

```c++
std::vector<Pt> p;
Pt s(0, 0);
for (int i = 0; i < n; i++) {
    Pt t;
    std::cin >> t;
    if (t.x == 0 && t.y == 0) {
        continue;
    }
    p.push_back(t);
    if (t.y < 0 || (t.y == 0 && t.x < 0)) {
        s = s + t;
    }
    t = t * -1;
    p.push_back(t);
}

std::sort(p.begin(), p.end(), cmp<i64>);

double ans = 0;
for (auto t : p) {
    s = s + t;
    ans = std::max(ans, length(s));
}
```

## 凸包

若直线 $l_2$ 在 $l_1$ 与 $l_3$ 交点的下方，则被遮挡
