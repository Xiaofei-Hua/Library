# **Dynamic Programming**

## 排列 $dp$ / 插入 $dp$

通常情况下从前到后枚举 $[0, n)$ 每个值，在决策中选择当前数字在哪个位置

状态设计一般为 $dp_{i, j}$ 表示已经插入了 $1$ 到 $i$ ，形成了 $j$ 个段，连续段一旦形成就不允许断开。考虑在坐标轴上，横坐标为下标，纵坐标为数值，每一段为链接的连续的 $M$ 形状折线。每次插入一个新的数，可以插入到原段的左侧或右侧；可以新形成一段；还可以插入两段中间形成一个新段。



[P9197 [JOI Open 2016\] 摩天大楼 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P9197)

微元贡献法：考虑一种差分的思想，$a_j - a_i = \sum_{k=i}^{j-1} a_{k+1} - a_k$ ，则此时 $a_{k+1} - a_k$ 对总答案的贡献为所有贡献中满足 $i \leq k < j$ 的 $a_j - a_i$ 数量

https://codeforces.com/problemset/problem/301/E

寻找计数性质，与相同数字的相邻次数有关

## 线性 $dp$

对于具有连续性质的限制，则优先考虑分段

### 状态设置为区间限制

#### 说明

例如 $dp[i][j]$ 的第二维表示条件关系 $\leq j$ 的所有方案的数目，在第 $i$ 层循环时，每次求出条件关系 $= j$ 的 $dp[i][j]$，将该层所有满足 $ = j$ 的方案求出后，再利用前缀和的思想求出所有满足 $\leq j$ 的方案  



#### 例题

你拿到了一个神秘的字符串，这个字符串的长度为 $n$ ，里面只有 $0,1,2$ 三种数。但是你意识到了事情并不简单，这个字符串实际上隐藏的是一个长度为 $n + 1$ 的排列。我们将字符串和排列的下标从$ 1 $开始标号，如果 $s[i] = 1$，那么说明排列 $a$ 的 $a_i \le a_{i + 1}$；如果 $s[i] = 2$ ，那么说明 $a_i \ge a_{i + 1}$；如果 $s[i] = 0$，那么说明 $a_i$ 和 $a_{i + 1}$ 的关系任意

状态设置为 $dp[i][j]$ 表示前 $i$ 个数都已经排列完成，且最后一位 $\leq j$ 的所有方案数 
对于新插入的第 $i + 1$ 个数 $j$ ，此时我们需要求前 $i + 1$ 个数都已经排列完成，且最后一位 $= j$ 的所有方案数，对于前 $i$ 个已经排列好的数，我们将 $\geq j$ 的数 $+1$，将 $< j$ 的数保持不变，这样此前所有的相对关系仍不会发生变化，即可在第 $i + 1$ 位插入数 $j$



有 $n$ 根木棍, 第 $i$ 根木棍的长度为 $L_i$，$n$ 根木棍依次连结了一起，总共有 $n-1$ 个连接处。
现在允许你最多砍断 $m$ 个连接处， 砍完后 $n$ 根木棍被分成了很多段，要求满足总长度最大的一段长度最小, 并且输出有多少种砍的方法使得总长度最大的一段长度最小

状态设置为 $dp[i][j]$ 表示将木棍分为了 $i$ 段，且最后一段的结尾 $\leq j$ 的所有方案数



### 题意转化

#### 说明

当所求答案难以直接求出时，则进行函数变化或物理意义转化  
如求在某种限制下进行某个游戏的方案数量 $\sum_{i = 1}^{k} a_i^x$ 时，物理意义为 $x$ 个人同时进行这一种游戏且同时满足限制的方案的和  

#### 例题

游戏初始时，左侧上下两个管道分别有一定数量的小球（有深色球和浅色球两种类型），而右侧输出管道为空。每一次操作，可以从左侧选择一个管道，并将该管道中最右侧的球推入右边输出管道。  
假设上管道中有 $n$ 个球,下管道中有 $m$ 个球，则整个游戏过程需要进行 $n+m$ 次操作，即将所有左侧管道中的球移入输出管道。最终 $n +m$ 个球在输出管道中从右到左形成输出序列。  
假设最终可能产生的不同种类的输出序列共有 $K$ 种，其中第 $i$ 种输出序列的产生方式(即不同的操作方式数目)有 $a_i$ 个。小 $X$ 希望计算得到 $\sum_{i = 1}^{k}{a_i}^2$ 

状态设置为 $dp[i][j][k][l]$ 表示第一位玩家在上管道中选择了 $i$ 个，在下管道中选择了 $j$ 个，第二位玩家在上管道中选择了 $k$ 个，在下管道中选择了 $l$ 个，且选择的序列相同的方案数。  
易得 $i + j = k + j$ 可以优化掉一维空间



吉吉国王在探险的时候发现了一个奇怪的游戏，这个游戏有 $n$ 盏灯，每盏灯刚开始都是熄灭的。有灯那么必然就有开关，吉吉国王在另外一侧发现了 $m$ 个开关，对于每个开关，都控制着一定数量的灯。对于每个开关，吉吉国王可以选择按一下，或者不按，每次按下，这个开关都会让其控制的灯的状态取反。
设 $x$ 是最后亮着的灯的个数，现在需要求 $E(x^3) \times 2^m$ 的值，$E$ 表示取期望

分析所求式子得：  
$E(x^3) \times 2^m = \sum_{x = 0}^{n}x^3\times(\frac{cnt_x}{2^m}) \times 2^m = \sum_{x = 0}^{n}x^3\times cnt_x = \sum_{count = 0}^{2^m} \sum_{count \Rightarrow x} x^3$  
即可转化为三个人玩同一个游戏，对于每个不同按键的序列，求亮灯数量相同的方案的个数  
状态设置为 $dp[i][st]$ 表示对前 $i$ 个开关操作过后，三个灯的状态为 $st$ 的方案数



### 数字三角形应用

#### 例题

在 $n \times m$ 的矩阵中每个格子的高度为 $a_{i, j}$ ，求最大的 $l$ 满足在 $l \times l$ 的矩阵中的最小值 $\geq l$。  

设置状态 $dp[i][j]$ 为以 $i, j$ 为右下角的满足题设的方阵的边长为多少

****

## 区间 $dp$

### 状态设置偏某一端点 $/$ 状态转移以某一端点开始

#### 说明

当枚举循环变量时，不以区间大小进行枚举 $(for\ len : 1 \sim n)$，而是以某一端点进行枚举 $(for\ l/r : 1 \sim n)$ 



#### 例题

统计满足以下条件的长度为 $n$ 的 $01$ 串的数量，若 $a[i][j] = 1$ 则 $s[i] \dots s[j]$ 相同，若 $a[i][j] = 2$ 则 $s[i] \dots s[j]$ 至少有两个不同

状态设置为 $dp[l][r]$，对于 $a[1][r],a[2][r],a[3][r], \dots, a[l][r]$ 构成的序列，$[1 \dots l - 1]$ 为2，$[l \dots r]$ 为1的所有方案数

****

## 状压 $dp$

状态压缩路径，对于 $n \times m$ 的矩阵，可采用 $n + m$ 的二进制位进行状压，第 $i$ 位为 $0$ 意味着第 $i$ 步向下走，为 $1$ 以为着向右走

****

## 斜率优化 $dp$

将状态转移方程转化为形如 $dp_i = min/max \{y_j - k_i \times x_j \} + C_i$ 的式子  

维护凸包 $\{(x_j, y_j)\}$，其中 $x_j$ 是与 $k_i$ 相乘的点，$y_j$ 是与 $i$ 独立的点

> 例如： $dp_i = min \{dp_j + c_i \times t_i - c_j \times t_i + s \times c_n - s \times c_j \}$  
> 可转化为：$dp_i = min \{ (dp_j - s \times c_j) - t_i \times c_j \} + c_i \times t_i + s \times c_n$，即$y_j = dp_j - s \times c_j,\ k_i = t_i,\ x_j = c_j$

若 $x, k$ 均单调不减，则单调队列队头元素即最优决策点

若 $x$ 单调不减，则二分查找单调队列中第一个斜率大于 $k_i$ （此处默认为下凸壳，若为上凸壳则查找第一个斜率小于 $k_i$ ）的线段，其左端点即为最优决策点

若 $x, k$ 均无单调性，则 $splay$ 或李超树

****

## $Slope \ trick$

考虑维护具有以下性质的函数：

1. 连续的一次分段函数
2. 凸函数
3. 每一段斜率较小（通常为 $O(n)$），且均为整数

维护在某个 $x_0$ 处的 $f(x_0)$ ，$k_0$ 以及函数每个斜率变化点的集合（即拐点集合）。具体地，如果函数在 $x$ 位置斜率增加了 $\Delta k$ ，就在集合中插入 $\Delta k$ 个 $x$ 。

可以快速维护多个操作：

1. 相加：将 $f(x_0)$ ，$k_0$ 直接相加，斜率变化点的集合直接合并。常用于加一次函数，绝对值函数。
2. 取前缀 / 后缀 $min$ ：去掉 $k < 0$ 或 $k > 0$ 的部分
3. 求 $min$ ，$argmin$ ：提前 $k = 0$ 的部分
4. 平移：维护 $f(x_0)$ ，$k_0$ 的变化，斜率变化点在全局打平移标记
5. 翻转：维护 $f(x_0)$ ，$k_0$ 的变化，斜率变化点在全局打翻转标记

常见的是维护凸包 $0$ 处的点值和凸包最低点的点值（即最小值）和函数的最后一段斜率

https://codeforces.com/problemset/problem/1534/G

[Sequence - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/CF13C)

```c++
i64 ans = 0;
for (int i = 0; i < n; i++) {
    int x;
    std::cin >> x;
    ans += x;
    heap.emplace(x);
    heap.emplace(x);
    heap.pop();
}
while (!heap.empty()) {
    ans -= heap.top();
    heap.pop();
}
std::cout << ans << "\n";
```

每次放入两个拐点，即绝对值函数的顶点，然后在末尾弹出斜率大于 $0$ 的段。

最初 `ans` 为最终凸包在 $0$ 处的点值（全改成 $0$ 的代价），然后减去所有拐点的很坐标（$-1 \times 贡献$）即得到凸包最低处的答案。



****

## $wqs$ 二分

考虑函数 $g(x)$ ，表示选择了 $x$ 个物品并满足一定条件的最值，题目要求求出特定的一个 $g(m)$ 。发现不考虑 $m$ 的限制会非常好求，且 $(x, g(x))$ 形成了一个凸壳，即可用 $wqs$ 二分来解决此问题

以最大值+上凸壳为例。我们用斜率 $k$ 的直线去尝试切这个凸壳，设切点为 $(p_k,g(p_k))$ 。可以发现，$p_k$ 随 $k$ 减小而增加（是单调的），所以考虑去二分这个斜率 $k$。我们知道，斜率为 $k$ 的直线切上凸壳于使得其在 $y$ 轴上的截距最大的一个点，即切点满足 $b=g(p_k)−k\times p_k$ 最大。发现右边的式子相当于给每个物品的价值减去 $k$，然后求出使得目标函数最大的值（取的物品的数量）$p_k$ 即可。

实际编码时：二分一个斜率 $k$ ，给题目所限制所取数量的物体加上 $k$ 的贡献，随后按照朴素的算法（即不考虑所取物品数量的限制）求出答案，再将答案减去题目中所限制物品选择的数量 $\times$ 斜率 $k$ ，即为最终答案

***

## $MaxAdd$ 卷积和闵可夫斯基和优化

形如 $f_i = max / min_{k=0}^i \{g_k + h_{i-k} \}$ 且具有凸性即可进行优化
转移方程形如 $f_{i, j} = max / min \ \{f_{i-1, j} + w_{i,i-j}\}$ ，若 $f, w$ 均具有凸性，可以使用闵可夫斯基和优化至 $O(n)$ 转移，常常改为分治求区间 $f$ 的值，总复杂度 $nlog(n)$ 

****

## 四边形不等式  决策单调性

矩阵行最小值位置：定义 $min_i(A)$ 为最大的整数 $k$ 满足 $\forall \ 1\leq j \leq n, A_{i,j} \geq A_{i,k}$ 

单调矩阵：对于  $n \times m$ 的矩阵 $A$ ，若 $\forall \ 1\leq i<  j \leq n, min_i(A) \leq min_j(A)$  ，则称该矩阵为单调矩阵

完全单调矩阵：对于  $n \times m$ 的矩阵 $A$ ，若其所有子矩阵均为单调矩阵，则称该矩阵为完全单调矩阵

四边形不等式与蒙日阵：对于  $n \times m$ 的矩阵 $A$ ，若对于任意 $1\leq i_1 \leq i_2 \leq n, 1\leq j_1 \leq j_2 \leq m$ ，均有 $A_{i_1,j_1} + A_{i_2, j_2} \leq A_{i_1, j_2} + A_{i_2, j_1}$ ，则称 $A$ 满足四边形不等式，同时称 $A$ 为蒙日阵



考虑以下两种形式的动态规划

1. $f_{i, j} = \underset{(k < j)}{min} \ f_{i-1, k} + w_{k, j}$ 
   此时从 $f_{i-1}$ 转移到 $f_i$ 时可以构造如下 $n \times n$ 的矩阵 $A$ ：
   $A_{x, y} = \begin{cases} f_{i-1,y} + w_{y, x},\quad y<x \\ +\infty, \quad \quad \quad \quad \ \ y\geq x \end{cases} \tag{1}$ 
   那么 $f_{i, x} = A_{x, min_x(A)}$ ，在矩阵 $A$ 满足四边形不等式时可以快速计算。由于转移时 $f_{i-1}$ 已知，不妨将其称为离线决策单调性

2. $f_{i} = min \ f_{j} + w_{j, i}  \ (j < i)$ 
   此时同样可以构造矩阵 $A$ ：
   $A_{x, y} = \begin{cases} f_{y} + w_{y, x},\quad y<x \\ +\infty, \quad \quad  \ \ \   \ \ y\geq x \end{cases} \tag{1}$ 
   那么 $f_{x} = A_{x, min_x(A)}$ ，在矩阵 $A$ 满足四边形不等式时可以快速计算。由于转移时 $f$ 未知，不妨将其称为在线决策单调性
   
   

决策单调性的决策点计算：

分治：对于单调矩阵 $A$ ，定义分支过程 $solve(l, r, x, y)$ 为计算 $[l, r)$ 行的 $min_i(A)$ ，且已知它们的范围在$[x, y)$ 内

那么找到中点 $m$ ，暴力在 $[x, y)$ 内计算出 $p = min_m(A)$ ，然后递归 $solve(l, m, x, p + 1)$ 与 $solve(m + 1, r, p, y)$ 。递归边界为 $l \geq r$ 或者 $x \geq y$ 

分治法的缺点在于只能解决离线问题，但它有一个比较好的性质。当 $A_{i, j}$ 无法直接求出，但拥有类似莫队的易加 / 易删性质，分治法仍可以求解。具体而言，维护两个指针和它对应矩阵的值



二维决策单调性：

最优搜素树问题，俗称石子合并

$f_{i, j} = \begin{cases} w_{i,i},\quad i =j \\ w_{i,j}+\underset{i \leq k <j}{min} \ f_{i,k}+f_{k,j}, \ i < j \\ 0,  \ \ \ \quad \ i > j \end{cases} \tag{1}$ 

区间包含单调性：对于 $n \times n$ 的方阵 $A$ ，若对所有的 $i \leq i\prime \leq j\prime \leq j$ 都有 $A_{i, j} \geq A_{i\prime, j\prime}$ ，则称 $A$ 满足区间包含单调性

设 $f_{i, j}$ 最小的最优转移点为 $K_{i, j}$ ，则有 $K_{i,j-1} \leq K_{i, j} \leq K_{i + 1, j}$ 

有了二维上的单调性，就可以按照区间长度顺序结算 $f$ 和 $K$ 

****

## 中位数与平均数相关

二分：

平均数：
判断平均数的经典策略：将所有数全部减去平均数 $mid$，判断是否有若干数之和不小于 $0$。
如果是，那么这些数的平均值就不小于 $mid$。

中位数：
判断中位数的经典策略：如果一个数大于等于 $mid$，就标记为 $1$；否则标记为 $-1$ 。判断是否有若干数标记之和大于 $0$。
如果是，那么这些数的中位数就不小于 $mid$。



****

## 计数 $dp$

### 容斥，求补集答案

### 非线性



从 $n$ 个数中选择一些数，保证顺序与原序相同，统计个数，需去重

状态为以前 $i$ 个数为结尾的数目，第 $i$ 轮枚举所有可用的作为结尾的数

对于有标号的点，循环中枚举最后一个标号出现在哪个集合里

****

## 期望 $dp$

### 循环依赖

### 非线性期望

### min-max容斥



若每一轮将 $n$ 个不同的数分为 $n$ 个不同的人，每个人各不相同，则对每个人来说有 $\frac{1}{n}$ 的概率得到 $i \  (1 \leq i\le n)$ 

求排名 $\rightarrow$ 求有多少个数比他大或比他小



期望的线性：例如任意两个位置的逆序对期望为 $\frac{1}{2}$ ，所有位置点对的期望的和即为整个序列的逆序对期望

You can use linearity of expectation to calculate the contribution of each pair independently.



维护区间出入的概率期望

****

## 树形 $dp$

对于树上的 $k$ 个点对，点对之间至少需要选择一条边，则选择一条边对所有点对所形成的状态，最多有 $O(k)$ 个。形式化的讲，对于每个点对中间的树链上的所有点异或 $rng()$ ，$k$ 次操作后把所有点加入集合，则集合的大小为 $O(k)$ 

普通的树形 $dp$ 为自底向上的形式，而对于自顶向下的树形 $dp$，$dp_u$ 为不考虑 $u$ 子树内状态的情况的 $dp$ 值，这样就可以从 $dp_{p_u}$ 转移到 $u$ 

若树形 $dp$ 式子中不只依赖于自己的儿子节点，还依赖于自己的父节点，朴素做法可以使用高斯消元 $O(n^3)$ 来解决。但对于叶子节点 $i$ ，只会和 $i$ 的父亲有关，因此设 $dp_i = A_i+B_i \times dp_{p_i}$ ，其中 $A, B$ 可以快速计算，将递推式子化简即可利用普通树形 $dp$ 得到 $A, B$，由于根节点无父节点，则即可得到根节点的 $dp$ 值，再从顶向下递推则可得到每个节点的 $dp$ 值

### $ddp$

通常转移方程为广义矩阵乘法 $*$ 

$f$ 为不带修改的平凡 $dp$ 状态，考虑 $g$ 为仅包含轻儿子分支的 $dp$ 状态，构造转移矩阵 $trans$ 仅包括 $g$ ，使得仅包括 $f$ 的初始矩阵 $base$ ，可以得出 $new \_base = trans \ * \ base$ 

考虑维护转移矩阵，最终答案即为根节点重链上的所有矩阵相乘

当出现修改时，仅修改重链头节点的父节点，因为当前节点所在的重链上的所有点都不会受影响，而当前重链为当前重链头节点的父节点的轻链

```c++
init[in[u]].a[1][0] += val - a[u];
a[u] = val;
while (u != -1) {
    auto prev = query(in[top[u]], in[bot[u]] + 1);
    modify(in[u], init[in[u]]);
    auto curr = query(in[top[u]], in[bot[u]] + 1);
    u = parent[top[u]];
    if (u == -1) {
        break;
    }
    auto delta = std::max(curr.a[0][0], curr.a[1][0]) - std::max(prev.a[0][0], prev.a[1][0]);
    init[in[u]].a[0][0] += delta;
    init[in[u]].a[0][1] += delta;
    init[in[u]].a[1][0] += curr.a[0][0] - prev.a[0][0];
}
```

***

## 拉格朗日插值优化值域 $dp$

多项式做前缀和指数$+1$ ，多项式做差分指数$-1$ ，多项式相乘指数相加，多项式相加指数取最大值

https://codeforces.com/problemset/problem/995/F

转移方程子树相乘，随后再做前缀和，即 $f[x]$ 是最高次是以 $x$ 为根的子树大小的多项式
