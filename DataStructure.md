# **Data Structure**

---

## 前缀和 差分

### 二维前缀积

$\frac{S(x_2,y_2) * S(x_1-1, y_1-1)}{S(x_2,y_1-1)*S(x_1-1,y_2)}$ 

### 二阶

$a_x = S_x - S_{x - 1}, \ b_x = a_x - a_{x - 1}$ 

$在树状数组中对\ b_x += v, \ 则\ a_x += x \times v$ 

$S_x = (x + 1) \times \sum_{i = 1}^{x}b_i - \sum_{i = 1}^{x}a_i$

### 三阶

$a_x = S_x - S_{x - 1}, \ b_x = a_x - a_{x - 1}, \ c_x = b_x - b_{x - 1}$ 

$在树状数组中对\ c_x += v, \ 则\ b_x += x \times v, \ a_x += x \times v \times v$ 

$S_x = (x + 1) \times (x + 2) \times \sum_{i = 1}^{x}c_i - (2 \times x + 3) \times \sum_{i = 1}^{x}b_i + \sum_{i = 1}^{x}a_i$

****

## 求左右第一个大于或小于当前值的位置

对于两两各不相同的值，用双向链表求解时，对于第 $i$ 次循环，所有未被循环访问过的位置的 $prev$ 和 $next$ 均合法，$prev[j]$ 的含义为 $j$ 位置左边第一个小于或大于 $i$ 的位置，$next[j]$ 的含义为 $j$ 位置右边第一个小于或大于 $i$ 的位置

****

## $DFS$ 序

### 链问题：

单点修改，链查询：修改子树区间，查询四条链的前缀和

链修改，单点查询：修改四条链的前缀和，查询子树区间和

****

标记永久化的原理简单来说就是修改时一路更改被影响到的点（即一次修改操作时最后影响的每段区间），询问时则一路累加路上的标记，从而省去下传标记的操作

****

## 线性基

对于线性基 $B$ 和二进制位 $w$ ： 

若线性基 $B$ 中存在第 $w$ 位为 $1$ 的数，则$B$ 中存在一个基的第 $w$ 位为 $1$ 

设 $B$ 中元素的个数为 $S$ ，则 $B$ 可以表示出 $2^S$ 个不同的数

如果 $B$ 中存在第 $w$ 为 $1$ 的数，则那 $2^S$ 个数中恰有 $2^{S-1}$ 个数的二进制第 $w$ 位为 $1$ ，另外 $2^{S-1}$ 个数的二进制第 $w$ 位为 $0$ 

如果 $B$ 中不存在 $w$ 为 $1$ 的数，显然不可能表示出二进制第 $w$ 位为 $1$ 数，全部的 $2^S$ 个数的二进制第 $w$ 位为 $0$ 



对于联通无向图 $G = (V,E)$ 以及 $G$ 的一棵生成树 $T$ ：

$G$ 中所有环（简单或非简单环）的异或和均可以被生成树中所有返祖边 $(x\to y)$ 对应的环 $(y \sim x \to y)$ 的异或和组成的线性基 $B$ 表示出来

点 $u$ 到点 $v$ 所有路径的异或和可以被 $T$ 中 $u$ 到 $v$ 的路径异或和 异或上 线性基 $B$ 表示出来

即 $u$ 到 $v$ 所有路径的异或和等于 $d_u \oplus d_v \oplus B$ ，其中 $d_x$ 表示 $x$ 到生成树根的路径异或和

****

## 同构树

计数同构无根树时，可以考虑树的重心为根，枚举最大子树的大小

****

## 上下界问题

线段树维护分段函数，支持函数合并

[P8518 [IOI2021\] 分糖果 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P8518)

如果区间内极差 $s \geq C$，则区间内必定包含最后两次碰上 $/$ 下界。然后就可以找出最后一次，进而求出答案。故线段树上二分即可。

对于有上下界的操作，每次相邻的碰上界和碰下界，他们原数值的差一定大于上下界之差，即只需要找到原数值最后一次碰上下界（即区间极差大于上下界之差），随后判断出触碰上下界的顺序，最后计算出对答案的影响。

```c++
std::pair<Info, Info> find(int p, int l, int r, int c, const Info &t) {
    if (r - l == 1) {
        return std::pair(info[p], t);
    }
    push(p);
    Info s = info[p * 2 + 1] + t;
    int m = (l + r) / 2;
    if (s.mx - s.mn <= c) {
        return find(p * 2, l, m, c, s);
    } else {
        return find(p * 2 + 1, m, r, c, t);
    }
}   

if (seg.info[1].mx - seg.info[1].mn <= c[i]) {
    // 最多碰一次上下界的情况
    res = sum - seg.info[1].mn;
} else {
    // s为倒数第二次碰上/下界的位置信息，t为s位置后面区间信息，来判断最后一次碰下/上界的信息
    auto [s, t] = seg.find(1, 0, q + 1, c[i], Info());
    if (s.mx > sum) {
        // s为碰上界位置，则最后的值为碰下界位置的增量
        res = sum - t.mn;
    } else {
        // s为碰下界位置，则最后的值为碰上界位置的增量
        res = c[i] - (t.mx - sum);
    }
}
```



****

## 莫队中避免出现 $log$

* $O(1)$ 插入元素
* $O(1)$ 删除元素
* $O(\sqrt n)$ 查询最小值

因此我们可以将值域分块，同时我们维护是否每个块中的元素全部出现，自小到大找到一个非满的块暴力查询即可

****

## 根号优化背包 / 不同种元素的划分方案数

对于 $\sum a_i = m$ ，$a_i \ge 0$ 

我们假设有三个相同权值的物品 $a, a , a$ 。注意到可以用 $a, 2a$ 替换掉这三个物品，我们可以重复这个过程直到每个权值最多有两件物品，因此至多有 $O(\sqrt m)$ 个物品，与此同时，我们能得到不同的 $a_i$ 的取值至多只有  $O(\sqrt m)$ 种

***

## 线段树

$Info$ 为半群积，$Tag$ 为自同态，$apply$ 为恒等映射

半群单点修改，区间查询

## 分块

对操作和询问分块：
https://www.luogu.com.cn/problem/P5443

静态区间众数：只可能是整块众数和散块中出现的数，预处理两个块之间的众数

静态区间逆序对：对值域分块 二次离线莫队

静态区间不同值的个数
树上路径不同值的个数
单点修改区间不同值的个数

## 二进制分组

```c++

// origin
std::vector<int> a;
// partition
std::vector<std::vector<int>> b;

int n = a.size();

// pop:
for (int i = 0; ~n >> i & 1; i++) {
    b.pop_back();
}

// insert:
int l = n & -n;
b.insert(b.end(), a.end() - l, a.end());
```
